## 注册 登录 接口

### 安全要求
- 防止验证码重复发送
- 防止多端登录
- 用户获取信息只能获取自己信息 要上锁 通过jwt拿user_id 然后调库拿信息

### 业务流程

#### 1. 用户注册流程

##### 1.1 验证码发送流程（防重复发送机制）
```
用户请求发送验证码
    ↓
检查Redis缓存：code_send_time:{email}
    ↓
如果存在且未过期（60秒内） → 返回错误："发送过于频繁，请{剩余秒数}秒后再试"
    ↓
如果不存在或已过期 → 继续发送流程
    ↓
调用gRPC服务发送验证码
    ↓
发送成功后，在Redis中存储：
  - verification_code:{email} → 验证码内容（5分钟TTL）
  - code_send_time:{email} → 当前时间戳（60秒TTL）
    ↓
同时将验证码记录存入数据库
    ↓
返回成功响应
```

##### 1.2 用户注册完整流程
```
用户收到发送过来的验证码
    ↓
用户提交注册信息与验证码
    ↓
从Redis中获取验证码：verification_code:{email}
    ↓
验证码校验：
  - 验证码不存在或已过期 → 返回错误："验证码已过期，请重新发送"
  - 验证码错误 → 返回错误："验证码错误"
  - 验证码正确 → 继续注册流程
    ↓
创建用户账号（密码使用Argon2id加密）
    ↓
清除Redis中的验证码缓存
    ↓
注册成功
```

#### 2. 用户登录

##### 2.1 登录流程
```
用户提交登录信息（邮箱/用户名 + 密码）
    ↓
查询用户信息
    ↓
密码校验（Argon2id验证）
    ↓
生成JWT Token（可以用来查询user_id 查询对应用户信息 并且新Token会覆盖旧Token）
    ↓
Redis操作：SETNX user_token:{user_id} {new_token} EX 604800
    ↓
判断SETNX结果：
  - 返回1（设置成功） → 首次登录或旧Token已过期 → 登录成功
  - 返回0（设置失败） → 用户已在其他设备登录 → 强制踢出
```

#### 3. 用户信息获取
```
获取请求头中的JWT Token
    ↓
验证Token有效性
    ↓
从Token中解析user_id
    ↓
根据user_id查询用户信息
    ↓
返回用户信息（仅限本人信息）
```